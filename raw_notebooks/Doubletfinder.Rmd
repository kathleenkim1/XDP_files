---
title: "R Notebook"
output: html_notebook
---

```{r}
library(Seurat)
library(Matrix)
library(rhdf5)
library(dplyr)
library(qs)
library(ggplot2)
```


```{r}
library_list = list("CaH_rxn1", "CaH_rxn2", "CaH_rxn3", "CaH_rxn4")
RAW_COUNTS_BASENAME = "cellranger/raw_feature_bc_matrix.h5"
FILTERED_COUNTS_BASENAME = "cellranger/filtered_feature_bc_matrix.h5"
MOLECULE_INFO_BASENAME = "cellranger/molecule_info.h5"
DONOR_ID_BASENAME = "vireo_final_out/donor_ids.tsv"
CELLBENDER_BASENAME = "filtered_feature_bc_matrix/pXDPsHSrCaiv1d240321_out_filtered.h5"
this_base_path = "/broad/macosko/kimkathl/Cellbender_doublets"

raw_dgc_list = list()
filtered_dgc_list = list()
mol_df_list = list()
donor_ids_list = list()
metadata_df_list = list()
seurat_object_list = list()

#helper function for cellbender loading
sum_duplicate_rownames_of_dgc_matrix=function(dgc){   
    # some umi_data has repeated rownames which causes problems down the road
    # we will sum the umi counts in these rows
    # collect rows with duplicate rownames as a dataframe
    n_occur = data.frame(table(rownames(dgc)))
    repeated_rownames = n_occur[n_occur$Freq > 1,]$Var1
    duplicated_dgc = as.data.frame(dgc[rownames(dgc) %in% repeated_rownames,])
    duplicated_dgc['symbol'] = sub("\\.\\d$", "", rownames(duplicated_dgc))

    # sum across numeric columns
    numeric_cols = setdiff(colnames(duplicated_dgc), "symbol")
    summed_duped_umi_rows = duplicated_dgc %>%
        group_by(symbol) %>%
        summarise_at(vars(numeric_cols), sum, na.rm = TRUE) %>%
        ungroup() %>%
        as.data.frame()
    # set rownames to be symbol column, then remove it
    rownames(summed_duped_umi_rows) = summed_duped_umi_rows$symbol
    summed_duped_umi_rows = summed_duped_umi_rows[, !(names(summed_duped_umi_rows) %in% c('symbol'))]

    # Hack
    # each round of the loop will remove ONE of each duplicate row 
    for(i in 1:max(n_occur$Freq)){
        dgc = dgc[!rownames(dgc) %in% repeated_rownames,]
    }

    # finally, replace the deduped rows with the summed rows via an rbind
    dgc = rbind(dgc, as(summed_duped_umi_rows, "sparseMatrix"))

    return(dgc)
}

for (name in library_list){
   cat(name)
   cat("\n")

   raw_counts_path = file.path(this_base_path, name, RAW_COUNTS_BASENAME)
   filtered_counts_path = file.path(this_base_path, name, FILTERED_COUNTS_BASENAME)
   molecule_info_path = file.path(this_base_path, name, MOLECULE_INFO_BASENAME)
   donor_id_path = file.path(this_base_path, name, DONOR_ID_BASENAME)
  
   # load the filtered counts
   filtered_dgc = Read10X_h5(filtered_counts_path)
   filtered_dgc_list[[name]] = filtered_dgc

print("READING RAW DGC .H5")
   raw_counts = Read10X_h5(raw_counts_path)
   raw_dgc_list[[name]] = raw_counts

   cd = data.frame(
       row.names=colnames(raw_counts),
       nUMI=colSums(raw_counts),
       log10_nUMI = log10(colSums(raw_counts) + 1),
       nGene=colSums(raw_counts > 0),
       is_in_filtered=colnames(raw_counts) %in% colnames(filtered_dgc_list[[name]])
   )

# load the molecule data such that you can map the barcodes to what came out of CellRanger
   # load umi_type to get whether or not the umi was intronic
   h5fetch = function(x){return(h5read(molecule_info_path, x))}
   mol_df = data.frame(
               barcode=h5fetch("barcodes")[h5fetch("barcode_idx")+1] %>% paste0("-1"),
               feature=h5fetch("features/name")[h5fetch("feature_idx")+1],
               umi=h5fetch("umi"),
               umi_type=h5fetch("umi_type"),
               count=h5fetch("count")
       )
      
   # only consider cells that are in the filtered umi data
   mol_df = mol_df[mol_df$barcode %in% colnames(filtered_dgc),]

mol_df_grouped = mol_df %>% group_by(barcode) %>%
       summarize(
           nUmi=n(),
           nRead=sum(count),
           pct_intronic=sum(umi_type==0)/nUmi)
   rownames(mol_df_grouped) = mol_df_grouped$barcode
   mol_df_list[[name]] = mol_df_grouped

donor_ids = read.table(donor_id_path, header=T)
  donor_ids = donor_ids[, c("cell", "donor_id", "prob_max")]
  donor_ids_list[[name]] = donor_ids

mol_df_rxn = mol_df_list[[name]] 
  metadata = merge(donor_ids, mol_df_rxn, by.x = "cell", by.y = "barcode")
  rownames(metadata) <- metadata$cell
  all(colnames(filtered_dgc) == rownames(metadata))
  metadata <- metadata[match(colnames(filtered_dgc), rownames(metadata)), ]
  all(colnames(filtered_dgc) == rownames(metadata))

file_path = file.path(this_base_path, name, CELLBENDER_BASENAME)
    h5_data = h5read(file_path, "/matrix")
    counts = h5_data$data
    indices = h5_data$indices
    indptr = h5_data$indptr
    barcodes = h5_data$barcodes
    num_genes = length(h5_data$features$name)  # Number of genes
    num_cells = length(barcodes)  # Number of cells

    counts_matrix = sparseMatrix(i=indices + 1,  # add 1 for 1-based indexing in R
                                    p=indptr,
                                    x=counts,
                                    dims=c(num_genes, num_cells))

    rownames(counts_matrix) = h5_data$features$name # set rownames to be genes
    colnames(counts_matrix) = barcodes # set colnames to be cell barcodes

    # now we want to look only at cells that are in BOTh the CellRanger and CellBender objects
    # use filtered_dgc from earlier in the loop
    cellranger_filtered = filtered_dgc[, colnames(filtered_dgc) %in% all_of(colnames(counts_matrix))]
    counts_matrix_filtered = counts_matrix[, colnames(counts_matrix) %in% all_of(colnames(cellranger_filtered))]
    print(dim(counts_matrix_filtered))
   print("1")
    # for whatever reason, there can be duplicated rownames (i.e. genes) in the cellbender output, causing errors later on. Sum these together.
    counts_matrix_filtered = sum_duplicate_rownames_of_dgc_matrix(counts_matrix_filtered) 
    print(dim(counts_matrix_filtered))
   print("2")
    counts_matrix_filtered = counts_matrix_filtered[, match(colnames(cellranger_filtered), colnames(counts_matrix_filtered))]
    print(dim(counts_matrix_filtered))
   print("3")

# create your metadata here....
metadata = metadata[rownames(metadata) %in% colnames(counts_matrix_filtered), ]

    metadata_df_list[[name]] = metadata 
    # add metadata argument to CreateSeuratObject

# Compare the first few entries directly
head(colnames(counts_matrix_filtered))
head(metadata$cell)
# Sort both and compare
all(sort(colnames(counts_matrix_filtered)) == sort(metadata$cell))
# Check types
str(colnames(counts_matrix_filtered))
str(metadata$cell)
# Convert both to character if needed
metadata$cell <- as.character(metadata$cell)
colnames(counts_matrix_filtered) <- as.character(colnames(counts_matrix_filtered))
# Check unique values
unique(colnames(counts_matrix_filtered))[1:10]  # First 10 in counts_matrix
unique(metadata$cell)[1:10]  # First 10 in metadata
metadata_ordered <- metadata[match(colnames(counts_matrix_filtered), metadata$cell), ]

cellbender_sobj = CreateSeuratObject(counts_matrix_filtered, meta.data = metadata)

seurat_object_list[[name]] = cellbender_sobj

}
seurat_object_list
```

```{r}
CaH_rxn1_cellbender = seurat_object_list[["CaH_rxn1"]]
CaH_rxn2_cellbender = seurat_object_list[["CaH_rxn2"]]
CaH_rxn3_cellbender = seurat_object_list[["CaH_rxn3"]]
CaH_rxn4_cellbender = seurat_object_list[["CaH_rxn4"]]

qsave(CaH_rxn1_cellbender, "Cellbender_doublets/CaH_rxn1_cellbender.qs")
qsave(CaH_rxn2_cellbender, "Cellbender_doublets/CaH_rxn2_cellbender.qs")
qsave(CaH_rxn3_cellbender, "Cellbender_doublets/CaH_rxn3_cellbender.qs")
qsave(CaH_rxn4_cellbender, "Cellbender_doublets/CaH_rxn4_cellbender.qs")
```

```{r}
CaH_rxn1_cellbender@meta.data
CaH_rxn2_cellbender@meta.data
```

#calcualte pct mito
```{r}
# Step 1: Identify mitochondrial genes (assuming mitochondrial genes start with "MT-" in gene names)
mito_genes <- grep(pattern = "^MT-", x = rownames(CaH_rxn4_cellbender), value = TRUE)
length(mito_genes)
# Step 2: Access counts from RNA assay using GetAssayData()
mito_counts <- Matrix::colSums(GetAssayData(CaH_rxn4_cellbender, assay = "RNA", slot = "counts")[mito_genes, ])
total_counts <- Matrix::colSums(GetAssayData(CaH_rxn4_cellbender, assay = "RNA", slot = "counts"))

# Step 3: Calculate percentage of mitochondrial counts
pct_mito <- (mito_counts / total_counts) * 100

# Step 4: Add this as a metadata column in Seurat object
CaH_rxn4_cellbender$pct_mito <- pct_mito

# Step 5: View the result
head(CaH_rxn4_cellbender$pct_mito)

CaH_rxn4_cellbender@meta.data
```

```{r}
table(CaH_rxn4_cellbender$donor_id)

hist(CaH_rxn4_cellbender$nUmi, breaks = 100)
hist(CaH_rxn4_cellbender$pct_intronic, breaks = 100)
hist(CaH_rxn4_cellbender$pct_mito, breaks = 100)
```

```{r}
CaH_rxn1_cellbender
filtered_CaH_rxn1_cellbender <- subset(CaH_rxn1_cellbender, subset = pct_mito < 10 & pct_intronic >= 0.25)
filtered_CaH_rxn1_cellbender = subset(filtered_CaH_rxn1_cellbender, subset = nUmi > 500)
filtered_CaH_rxn1_cellbender

CaH_rxn2_cellbender
filtered_CaH_rxn2_cellbender <- subset(CaH_rxn2_cellbender, subset = pct_mito < 10 & pct_intronic >= 0.25)
filtered_CaH_rxn2_cellbender = subset(filtered_CaH_rxn2_cellbender, subset = nUmi > 500)
filtered_CaH_rxn2_cellbender

CaH_rxn3_cellbender
filtered_CaH_rxn3_cellbender <- subset(CaH_rxn3_cellbender, subset = pct_mito < 10 & pct_intronic >= 0.25)
filtered_CaH_rxn3_cellbender = subset(filtered_CaH_rxn3_cellbender, subset = nUmi > 500)
filtered_CaH_rxn3_cellbender

CaH_rxn4_cellbender
filtered_CaH_rxn4_cellbender <- subset(CaH_rxn4_cellbender, subset = pct_mito < 10 & pct_intronic >= 0.25)
filtered_CaH_rxn4_cellbender = subset(filtered_CaH_rxn4_cellbender, subset = nUmi > 500)
filtered_CaH_rxn4_cellbender

filtered_CaH_rxn1_cellbender = subset(filtered_CaH_rxn1_cellbender, subset = donor_id != "unassigned")
filtered_CaH_rxn1_cellbender

filtered_CaH_rxn2_cellbender = subset(filtered_CaH_rxn2_cellbender, subset = donor_id != "unassigned")
filtered_CaH_rxn2_cellbender

filtered_CaH_rxn3_cellbender = subset(filtered_CaH_rxn3_cellbender, subset = donor_id != "unassigned")
filtered_CaH_rxn3_cellbender

filtered_CaH_rxn4_cellbender = subset(filtered_CaH_rxn4_cellbender, subset = donor_id != "unassigned")
filtered_CaH_rxn4_cellbender
```


#HVG calculation helper function
```{r}
getSeuratVarFeatureIntersectByCol = function(
   seurat_obj,
   subset_col,
   original_nfeatures,
   n_subsets_to_cover=NULL
){
  
   hvgs = list()


   unique_ids = unique(seurat_obj@meta.data[[subset_col]])


   if (is.null(n_subsets_to_cover)){
       n_subsets_to_cover = floor(length(unique_ids)/2)
   }


   i=1
   for (id in unique_ids) {
       print(paste("Subset", id, "--", i, "of", length(unique_ids)))
       i = i + 1
      
       seurat_subset = seurat_obj[, seurat_obj[[subset_col]] == id]
      
       if (ncol(seurat_subset) < 2){next}
      
       suppressWarnings({
           seurat_subset = FindVariableFeatures(
               seurat_subset, selection.method = "vst", nfeatures=original_nfeatures, verbose = TRUE)
       })
      
       hvgs[[id]] = getSeuratVarFeatures(seurat_subset)
      print(length(VariableFeatures(seurat_subset)))  # Should be > 0

   }


   common_hvgs = getCommonStrings(hvgs, n_subsets_to_cover)
   print(paste("Number of HVGs in common across", n_subsets_to_cover, "--", length(common_hvgs)))


   return(common_hvgs)
}


getSeuratVarFeatures = function(sobj){
    rna_assay <- GetAssay(sobj, assay = "RNA")  # Explicitly get the assay
    return(VariableFeatures(rna_assay))  # Use VariableFeatures() instead of direct slot access
}

# getSeuratVarFeatures = function(sobj){
#     # the magical incantation that returns the slot of the attribute of the slot that actually holds the list of variable feature -_-
#     return(sobj@assays$RNA@var.features)
# }

getCommonStrings <- function(list_of_lists, n) {
  # Create an empty list to store string occurrences
  string_occurrences <- list()

  # Iterate over each sublist
  for (sublist in list_of_lists) {
    # For each string in the sublist, increment its count in string_occurrences
    for (string in unique(sublist)) {
      if (!is.null(string_occurrences[[string]])) {
        string_occurrences[[string]] <- string_occurrences[[string]] + 1
      } else {
        string_occurrences[[string]] <- 1
      }
    }
  }

  # Filter the strings that occur at least n times
  common_strings <- names(string_occurrences)[string_occurrences >= n]

  return(common_strings)
}
```

#notworkign
```{r}
# Counts of super lowly expressed genes are essentially random
# Also, we don't really care about housekeeping genes that have almost the same expression in every cell
# Before clustering, we want to find "highly variable genes" (hvgs) that tend to be both highly expressed and vary a lot from cell to cell.
# we do this by finding hvgs in each participant individually, and collating the genes
# that are highly variable in at least half of donors.


# this code should take 3-10 minutes
hvgs = getSeuratVarFeatureIntersectByCol(filtered_CaH_rxn1_cellbender, subset_col="donor_id", original_nfeatures=2500)

n_dims_use=20


# now cluster
# the "%>%" lines are a little piece of syntax from the dyplr library,
# short for "apply the following transformation to the object"
# doing this line-by-line allows us to apply a sequence of transformations
filtered_CaH_rxn1_cellbender = (filtered_CaH_rxn1_cellbender
   %>% NormalizeData() # log normalizes raw counts
   %>% ScaleData(features=hvgs, split.by="donor_id") # within each cell, for each gene scale the data (i.e. subtract the donor's mean and divide by the donor's standard deviation of that gene)
   %>% RunPCA(features=hvgs, npcs=n_dims_use) # Reduce the dimensions to the n_dims_use dimensions that best explain the data https://en.wikipedia.org/wiki/Principal_component_analysis
   %>% FindNeighbors(dims = 1:n_dims_use) # Finds every cells closest neighbors in the PCA space
   %>% FindClusters(resolution = 0.2) # finds clusters at a variety of resolutions
   %>% FindClusters(resolution = 0.3) # after clustering, the cluster labels are accessible via filtered_merged_caudate$RNA_snn_res.{resolution}
   %>% FindClusters(resolution = 0.4) # e.g.: filtered_merged_caudate$RNA_snn_res.0.4 here
   %>% FindClusters(resolution = 0.5)
   %>% FindClusters(resolution = 0.6)
   %>% FindClusters(resolution = 0.7)
   %>% FindClusters(resolution = 0.8)
   %>% FindClusters(resolution = 0.9)
   %>% FindClusters(resolution = 1)
   %>% RunUMAP(dims = 1:n_dims_use) # projects the PCA onto 2 dimensions, such that both "global structure" and "local structure" are optimally preserved
)


# Now we can plot the data and just see what it looks like


setwh = function(w, h){
   # set the width of the ensuing figures to w, height to h
   options(repr.plot.width = w, repr.plot.height = h)
}

filtered_CaH_rxn1_cellbender@meta.data$GT = "Singlet"
filtered_CaH_rxn1_cellbender$GT[filtered_CaH_rxn1_cellbender$donor_id == "doublet"] = "Doublet"


DimPlot(filtered_CaH_rxn1_cellbender, group.by = "donor_id") 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "GT") 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.2", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.3", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.4", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.5", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.6", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.7", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.8", label=T) 

filtered_CaH_rxn1_cellbender
#qsave(filtered_merged_caudate, "somewhere/cozy")

```

```{r}
hvgs = getSeuratVarFeatureIntersectByCol(filtered_CaH_rxn1_cellbender, subset_col="donor_id", original_nfeatures=2500)

n_dims_use=20

filtered_CaH_rxn1_cellbender <- filtered_CaH_rxn1_cellbender %>%
   NormalizeData() %>%
   { hvgs <- getSeuratVarFeatureIntersectByCol(., subset_col="donor_id", original_nfeatures=2500); . } %>%
   ScaleData(features=hvgs, split.by="donor_id") %>%
   { VariableFeatures(.) <- hvgs; . } %>%  # Ensure HVGs are stored
   RunPCA(features=hvgs, npcs=n_dims_use) %>%
   FindNeighbors(dims = 1:n_dims_use) %>%
   FindClusters(resolution = 0.2) %>%
   FindClusters(resolution = 0.3) %>%
   FindClusters(resolution = 0.4) %>%
   FindClusters(resolution = 0.5) %>%
   FindClusters(resolution = 0.6) %>%
   FindClusters(resolution = 0.7) %>%
   FindClusters(resolution = 0.8) %>%
   FindClusters(resolution = 0.9) %>%
   FindClusters(resolution = 1) %>%
   RunUMAP(dims = 1:n_dims_use)

# Check if HVGs are retained:
print(length(VariableFeatures(filtered_CaH_rxn1_cellbender)))  # Should be ~2200+

filtered_CaH_rxn1_cellbender
```

```{r}
filtered_CaH_rxn1_cellbender@meta.data$GT = "Singlet"
filtered_CaH_rxn1_cellbender$GT[filtered_CaH_rxn1_cellbender$donor_id == "doublet"] = "Doublet"


DimPlot(filtered_CaH_rxn1_cellbender, group.by = "donor_id") 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "GT") 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.2", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.3", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.4", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.5", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.6", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.7", label=T) 
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "RNA_snn_res.0.8", label=T) 
```

```{r}
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("SYT1", "RBFOX3", "GAD2", "SLC17A6"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("AQP4", "GINS3", "GFAP"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("C1QA", "C1QB", "CX3CR1", "P2RY12"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("FLT1", "DCN", "RGS5"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("OLIG1", "MOG", "MOBP"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("OLIG2", "VCAN", "GAPDH"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("ZBBX", "CFAP157", "CFAP299", "BSG"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("CD96", "NKG7", "SKAP1"), raster = F)
FeaturePlot(filtered_CaH_rxn1_cellbender, features = c("UBB", "GAPDH", "TUBB2A"),raster=FALSE) 
```

```{r}
 marker_genes <- c("SYT1", "RBFOX3", "GAD2", "SLC17A6","AQP4", "GINS3", "GFAP","C1QA", "C1QB", "CX3CR1", "P2RY12","FLT1", "DCN", "RGS5", "OLIG1", "MOG", "MOBP", "OLIG2", "VCAN", "GAPDH","ZBBX", "CFAP157", "CFAP299", "BSG","CD96", "NKG7", "SKAP1")
 Dotplot = DotPlot(object = filtered_CaH_rxn1_cellbender, features = marker_genes, group.by = "RNA_snn_res.0.3")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)
```

```{r}
Idents(filtered_CaH_rxn1_cellbender) = filtered_CaH_rxn1_cellbender$RNA_snn_res.0.3

classes = c("oligo", "astrocyte", "neuron", "oligo", "microglia", "oligo", "oligo", "astrocyte", "opc", "oligo", "endothelial", "ependymal", "neuron", "neuron", "oligo", "neuron", "immune", "microglia")


filtered_CaH_rxn1_cellbender= assignCellClasses(filtered_CaH_rxn1_cellbender, classes=classes, cluster_col="RNA_snn_res.0.3", class_col = "cell_class")

DimPlot(filtered_CaH_rxn1_cellbender, group.by = "cell_class" ,label = T, raster = FALSE)
DimPlot(filtered_CaH_rxn1_cellbender, group.by = "GT" ,label = T, raster = FALSE)
```


#Doublet Finder
```{r}
#remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')
#library(DoubletFinder)
```

```{r}
filtered_CaH_rxn1_cellbender
```
```{r}
DF_CaH_rxn1 = filtered_CaH_rxn1_cellbender
DF_CaH_rxn1
DF_CaH_rxn1@meta.data
```
```{r}
# Try running paramSweep() after explicitly setting HVGs
#Redoing findvariable...doesn't seem right
DF_CaH_rxn1 <- FindVariableFeatures(DF_CaH_rxn1, selection.method = "vst", nfeatures = 2000)
sweep.res.list_CaH_rxn1 <- paramSweep(DF_CaH_rxn1, PCs = 1:10, sct = FALSE)
```


```{r}
## pK Identification (no ground-truth) ---------------------------------------------------------------------------------------
sweep.stats_CaH_rxn1 <- summarizeSweep(sweep.res.list_CaH_rxn1, GT = FALSE)
bcmvn_CaH_rxn1 <- find.pK(sweep.stats_CaH_rxn1)
bcmvn_CaH_rxn1
```


```{r}
## pK Identification (ground-truth) ------------------------------------------------------------------------------------------
sweep.res.list_CaH_rxn1 <- paramSweep(DF_CaH_rxn1, PCs = 1:10, sct = FALSE)

gt.calls <- DF_CaH_rxn1@meta.data[rownames(sweep.res.list_CaH_rxn1[[1]]), "GT"]   ## GT is a vector containing "Singlet" and "Doublet" calls recorded using sample multiplexing classification and/or in silico geneotyping results 

sweep.stats_CaH_rxn1 <- summarizeSweep(sweep.res.list_CaH_rxn1, GT = TRUE, GT.calls = gt.calls)
bcmvn_CaH_rxn1 <- find.pK(sweep.stats_CaH_rxn1)
bcmvn_CaH_rxn1
```


#Allegedly 8% per 10K recovered cells (17K loading)
```{r}
## Homotypic Doublet Proportion Estimate -------------------------------------------------------------------------------------
homotypic.prop <- modelHomotypic(DF_CaH_rxn1@meta.data$cell_class)           ## ex: annotations <- 
nExp_poi <- round(0.075*nrow(DF_CaH_rxn1@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
```

```{r}
DF_CaH_rxn1 <- doubletFinder(DF_CaH_rxn1, 
                             PCs = 1:10, 
                             pN = 0.25, 
                             pK = 0.001, #0.04 
                             nExp = nExp_poi.adj, 
                             reuse.pANN = FALSE, 
                             sct = FALSE)
DF_CaH_rxn1@meta.data
```



```{r}
table(DF_CaH_rxn1$GT)
table(DF_CaH_rxn1$DF.classifications_0.25_0.01_511)
```

```{r}
# Assuming DoubletFinder has already been run and results are stored in the metadata of seu_kidney:
# - "DF.classifications_0.25_0.09_774" stores "Singlet" or "Doublet"
# - "pANN_0.25_0.09_774" stores the pANN scores for each cell

# First, create a new classification column that includes low-confidence and high-confidence doublets
DF_CaH_rxn1$doublet_confidence <- ifelse(
  DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511 == "Doublet" & 
    DF_CaH_rxn1@meta.data$pANN_0.25_0.01_511 < 0.5, "Low Confidence Doublet", 
  ifelse(
    DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511 == "Doublet" & 
      DF_CaH_rxn1@meta.data$pANN_0.25_0.01_511 >= 0.5, "High Confidence Doublet", 
    "Singlet"
  )
)

# Now plot the cells, coloring by the doublet classification
library(Seurat)
DimPlot(DF_CaH_rxn1, group.by = "doublet_confidence", 
        cols = c("Singlet" = "lightgrey", "Low Confidence Doublet" = "orange", "High Confidence Doublet" = "red"))

```

```{r}
library(caret)  # For confusionMatrix function

# Extract classifications
true_labels <- DF_CaH_rxn1@meta.data$GT  # Ground truth labels ("Singlet" / "Doublet")
pred_labels <- DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.04_511  # DoubletFinder output

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Generate confusion matrix
conf_matrix <- confusionMatrix(pred_labels, true_labels)
print(conf_matrix)

```



```{r}
library(caret)
library(ggplot2)
library(reshape2)  # For data manipulation

# Extract classifications
true_labels <- DF_CaH_rxn1@meta.data$GT  # Ground truth labels
pred_labels <- DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.04_511  # DoubletFinder results

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Compute confusion matrix
conf_matrix <- table(Predicted = pred_labels, True = true_labels)

# Convert to long format for ggplot2
conf_df <- as.data.frame(as.table(conf_matrix))
colnames(conf_df) <- c("Predicted", "True", "Freq")

ggplot(conf_df, aes(x = True, y = Predicted, fill = Freq)) +
    geom_tile() +
    geom_text(aes(label = Freq), color = "white", size = 6) +  # Add text labels
    scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Customize colors
    theme_minimal() +
    labs(title = "Confusion Matrix", x = "True Label", y = "Predicted Label") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
library(pROC)
library(ggplot2)

# Extract DoubletFinder pANN scores and Vireo ground truth
df <- DF_CaH_rxn1@meta.data %>%
  select(pANN_0.25_0.04_511, GT) %>%  # Replace 'pANN_col' with the actual column name in metadata
  mutate(
    GT_binary = ifelse(GT == "Doublet", 1, 0)  # Convert Vireo ground truth to 1 (doublet) / 0 (singlet)
  )

# Compute ROC Curve using pANN scores
roc_pANN <- roc(df$GT_binary, df$pANN_0.25_0.04_511)  # pANN_col should be the column with pANN scores

# Print AUC value
auc_value <- auc(roc_pANN)
print(paste("AUC =", round(auc_value, 3)))

# Plot ROC Curve
ggroc(roc_pANN) +
  ggtitle(paste("Vireo vs Doubletfinder (AUC =", round(auc_value, 3), ")")) +
  theme_minimal()

```



```{r}
DF_CaH_rxn1_temp = DF_CaH_rxn1
```


#Testing out different pK effects
#Conclusion: same amount of doublets, less confidence
```{r}
DF_CaH_rxn1_temp <- doubletFinder(DF_CaH_rxn1_temp, 
                             PCs = 1:10, 
                             pN = 0.25, 
                             pK = 0.21, 
                             nExp = nExp_poi.adj, 
                             reuse.pANN = FALSE, 
                             sct = FALSE)
DF_CaH_rxn1_temp@meta.data
```

```{r}
table(DF_CaH_rxn1_temp$GT)
table(DF_CaH_rxn1_temp$DF.classifications_0.25_0.21_511)
```

```{r}
# Assuming DoubletFinder has already been run and results are stored in the metadata of seu_kidney:
# - "DF.classifications_0.25_0.09_774" stores "Singlet" or "Doublet"
# - "pANN_0.25_0.09_774" stores the pANN scores for each cell

# First, create a new classification column that includes low-confidence and high-confidence doublets
DF_CaH_rxn1_temp$doublet_confidence <- ifelse(
  DF_CaH_rxn1_temp@meta.data$DF.classifications_0.25_0.21_511 == "Doublet" & 
    DF_CaH_rxn1_temp@meta.data$pANN_0.25_0.21_511 < 0.5, "Low Confidence Doublet", 
  ifelse(
    DF_CaH_rxn1_temp@meta.data$DF.classifications_0.25_0.21_511 == "Doublet" & 
      DF_CaH_rxn1_temp@meta.data$pANN_0.25_0.21_511 >= 0.5, "High Confidence Doublet", 
    "Singlet"
  )
)

# Now plot the cells, coloring by the doublet classification
library(Seurat)
DimPlot(DF_CaH_rxn1_temp, group.by = "doublet_confidence", 
        cols = c("Singlet" = "lightgrey", "Low Confidence Doublet" = "orange", "High Confidence Doublet" = "red")) + ggtitle("pk = 0.21")

```

```{r}
library(caret)  # For confusionMatrix function

# Extract classifications
true_labels <- DF_CaH_rxn1_temp@meta.data$GT  # Ground truth labels ("Singlet" / "Doublet")
pred_labels <- DF_CaH_rxn1_temp@meta.data$DF.classifications_0.25_0.21_511  # DoubletFinder output

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Generate confusion matrix
conf_matrix <- confusionMatrix(pred_labels, true_labels)

```

```{r}
library(caret)
library(ggplot2)
library(reshape2)  # For data manipulation

# Extract classifications
true_labels <- DF_CaH_rxn1_temp@meta.data$GT  # Ground truth labels
pred_labels <- DF_CaH_rxn1_temp@meta.data$DF.classifications_0.25_0.21_511  # DoubletFinder results

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Compute confusion matrix
conf_matrix <- table(Predicted = pred_labels, True = true_labels)

# Convert to long format for ggplot2
conf_df <- as.data.frame(as.table(conf_matrix))
colnames(conf_df) <- c("Predicted", "True", "Freq")

ggplot(conf_df, aes(x = True, y = Predicted, fill = Freq)) +
    geom_tile() +
    geom_text(aes(label = Freq), color = "white", size = 6) +  # Add text labels
    scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Customize colors
    theme_minimal() +
    labs(title = "Confusion Matrix, pk = 0.21", x = "True Label", y = "Predicted Label") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
library(pROC)
library(ggplot2)

# Extract DoubletFinder pANN scores and Vireo ground truth
df <- DF_CaH_rxn1_temp@meta.data %>%
  select(pANN_0.25_0.21_511, GT) %>%  # Replace 'pANN_col' with the actual column name in metadata
  mutate(
    GT_binary = ifelse(GT == "Doublet", 1, 0)  # Convert Vireo ground truth to 1 (doublet) / 0 (singlet)
  )

# Compute ROC Curve using pANN scores
roc_pANN <- roc(df$GT_binary, df$pANN_0.25_0.21_511)  # pANN_col should be the column with pANN scores

# Print AUC value
auc_value <- auc(roc_pANN)
print(paste("AUC =", round(auc_value, 3)))

# Plot ROC Curve
ggroc(roc_pANN) +
  ggtitle(paste("Vireo vs Doubletfinder, pk = 0.21 (AUC =", round(auc_value, 3), ")")) +
  theme_minimal()

```


#findmarkers, microglia doublets
```{r}
DF_CaH_rxn1_temp@meta.data
DF_CaH_rxn1_temp@meta.data$micro_doublets = paste0(DF_CaH_rxn1_temp$cell_class, "_", DF_CaH_rxn1_temp$GT)
table(DF_CaH_rxn1_temp$micro_doublets)
```

```{r}
Idents(DF_CaH_rxn1_temp) = DF_CaH_rxn1_temp$micro_doublets
a =  FindMarkers(DF_CaH_rxn1_temp, ident.1 = "microglia_Doublet", ident.2 = "microglia_Singlet")
a
```
```{r}
a_sig = subset(a, subset = p_val_adj < 0.05)
a_sig
```

```{r}
write.csv(a_sig, "microglia_doublet_cluster.csv")
```


#manual clustering

```{r}
DF_CaH_rxn1@meta.data
```


```{r}
Idents(DF_CaH_rxn1) = "cell_class"
DimPlot(DF_CaH_rxn1, label = T)

marker_genes <- c("CD96", "CX3CR1", "P2RY12", "C1QB", "C1QA", "CASZ1", "FLT1", "TF", "MOBP", "MOG", "MBP", "OLIG2", "OLIG1", "ST18", "GFAP", "AQP4", "SEMA3E", "EPHA4", "PPP1R1B", "DRD2", "DRD1", "GAD2", "GAD1", "SYT1", "RBFOX3", "SLC17A6", "SLC17A7")

Dotplot = DotPlot(object = DF_CaH_rxn1, features = marker_genes, group.by = "cell_class")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)


 marker_genes <- c("SYT1", "RBFOX3", "GAD2", "SLC17A6","AQP4", "GINS3", "GFAP","C1QA", "C1QB", "CX3CR1", "P2RY12","FLT1", "DCN", "RGS5", "OLIG1", "MOG", "MOBP", "OLIG2", "VCAN", "GAPDH","ZBBX", "CFAP157", "CFAP299", "BSG","CD96", "NKG7", "SKAP1")
 Dotplot = DotPlot(object = DF_CaH_rxn1, features = marker_genes, group.by = "cell_class")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)
```
```{r}
DimPlot(DF_CaH_rxn1, group.by = "donor_id")
```
```{r}
DF_CaH_rxn1_KK = subset(DF_CaH_rxn1, subset = donor_id != "doublet")
DF_CaH_rxn1_KK
DF_CaH_rxn1_KK@meta.data
DimPlot(DF_CaH_rxn1_KK)
```
```{r}
table(DF_CaH_rxn1_KK$cell_class) 
```


```{r}
temp_sobj = subset(DF_CaH_rxn1_KK, subset = cell_class == "neuron")

# this code should take 3-10 minutes
hvgs = getSeuratVarFeatureIntersectByCol(temp_sobj, subset_col="donor_id", original_nfeatures=2500)
n_dims_use=20
temp_sobj = (temp_sobj
   %>% NormalizeData() # log normalizes raw counts
   %>% ScaleData(features=hvgs, split.by="donor_id") # within each cell, for each gene scale the data (i.e. subtract the donor's mean and divide by the donor's standard deviation of that gene)
   %>% RunPCA(features=hvgs, npcs=n_dims_use) # Reduce the dimensions to the n_dims_use dimensions that best explain the data https://en.wikipedia.org/wiki/Principal_component_analysis
   %>% FindNeighbors(dims = 1:n_dims_use) # Finds every cells closest neighbors in the PCA space
   %>% FindClusters(resolution = 0.2) # finds clusters at a variety of resolutions
   %>% FindClusters(resolution = 0.3) # after clustering, the cluster labels are accessible via filtered_merged_caudate$RNA_snn_res.{resolution}
   %>% FindClusters(resolution = 0.4) # e.g.: filtered_merged_caudate$RNA_snn_res.0.4 here
   %>% FindClusters(resolution = 0.5)
   %>% FindClusters(resolution = 0.6)
   %>% FindClusters(resolution = 0.7)
   %>% FindClusters(resolution = 0.8)
   %>% FindClusters(resolution = 0.9)
   %>% FindClusters(resolution = 1)
   %>% RunUMAP(dims = 1:n_dims_use) # projects the PCA onto 2 dimensions, such that both "global structure" and "local structure" are optimally preserved
)

setwh = function(w, h){
   # set the width of the ensuing figures to w, height to h
   options(repr.plot.width = w, repr.plot.height = h)
}

DimPlot(temp_sobj, group.by = "donor_id") 
DimPlot(temp_sobj, group.by = "GT") 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.2", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.3", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.4", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.5", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.6", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.7", label=T) 
DimPlot(temp_sobj, group.by = "RNA_snn_res.0.8", label=T) 
```


```{r}
FeaturePlot(temp_sobj, features = c("SYT1", "RBFOX3", "GAD2", "SLC17A6"), raster = F)
FeaturePlot(temp_sobj, features = c("AQP4", "GINS3", "GFAP"), raster = F)
FeaturePlot(temp_sobj, features = c("C1QA", "C1QB", "CX3CR1", "P2RY12"), raster = F)
FeaturePlot(temp_sobj, features = c("FLT1", "DCN", "RGS5"), raster = F)
FeaturePlot(temp_sobj, features = c("OLIG1", "MOG", "MOBP"), raster = F)
FeaturePlot(temp_sobj, features = c("OLIG2", "VCAN", "GAPDH"), raster = F)
FeaturePlot(temp_sobj, features = c("ZBBX", "CFAP157", "CFAP299", "BSG"), raster = F)
FeaturePlot(temp_sobj, features = c("CD96", "NKG7", "SKAP1"), raster = F)
FeaturePlot(temp_sobj, features = c("UBB", "GAPDH", "TUBB2A"),raster=FALSE) 
```

```{r}
marker_genes <- c("CD96", "CX3CR1", "P2RY12", "C1QB", "C1QA", "CASZ1", "FLT1", "TF", "MOBP", "MOG", "MBP", "OLIG2", "OLIG1", "ST18", "GFAP", "AQP4", "SEMA3E", "EPHA4", "PPP1R1B", "DRD2", "DRD1", "GAD2", "GAD1", "SYT1", "RBFOX3", "SLC17A6", "SLC17A7")

Dotplot = DotPlot(object = temp_sobj, features = marker_genes, group.by = "RNA_snn_res.0.6")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)


 marker_genes <- c("SYT1", "RBFOX3", "GAD2", "SLC17A6","AQP4", "GINS3", "GFAP","C1QA", "C1QB", "CX3CR1", "P2RY12","FLT1", "DCN", "RGS5", "OLIG1", "MOG", "MOBP", "OLIG2", "VCAN", "GAPDH","ZBBX", "CFAP157", "CFAP299", "BSG","CD96", "NKG7", "SKAP1")
 Dotplot = DotPlot(object = temp_sobj, features = marker_genes, group.by = "RNA_snn_res.0.6")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)
```
```{r}
temp_sobj= KK_CaH_rxn1_opc_clean
```


```{r}
KK_CaH_rxn1_oligo_clean = temp_sobj
```


```{r}
KK_CaH_rxn1_neuron_clean = subset(temp_sobj, subset = RNA_snn_res.0.6 != 9 & RNA_snn_res.0.6 != 11)
KK_CaH_rxn1_neuron_clean= temp_sobj
```


```{r}
KK_CaH_rxn1_astro_clean
KK_CaH_rxn1_endo_clean
KK_CaH_rxn1_ependymal_clean
KK_CaH_rxn1_immune_clean
KK_CaH_rxn1_micro_clean
KK_CaH_rxn1_oligo_clean
KK_CaH_rxn1_opc_clean
KK_CaH_rxn1_neuron_clean
```



```{r}
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.2", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.3", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.4", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.5", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.6", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.7", label=T) 
DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "RNA_snn_res.0.8", label=T) 
```

```{r}
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("SYT1", "AQP4", "C1QA","FLT1"),raster=FALSE)
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("OLIG1", "OLIG2", "MOG" ,"CD96"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("MBP", "MOBP", "TF", "ST18"),raster=FALSE)
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("RBFOX3", "CX3CR1", "GFAP" ,"AQP4"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("GAD1", "GAD2", "SLC17A7" ,"SLC17A6"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("DRD1", "DRD2", "CASZ1" ,"PPP1R1B"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("EPHA4", "SEMA3E", "SLC17A7" ,"SLC17A6"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("P2RY12", "CX3CR1", "C1QB", "BCAS1"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("SEMA5B", "KREMEN1", "PDE1C"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("TAC1", "NNAT", "OPRM1", "ID4"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("SGK1", "EPHA4", "SV2B"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("SST", "CALB1", "PVALB", "LAMP5"),raster=FALSE) 
FeaturePlot(KK_CaH_rxn1_neuron_clean, features = c("pct_mito"),raster=FALSE) 


```


```{r}
DimPlot(KK_CaH_rxn1_neuron_clean)

marker_genes <- c("CD96", "CX3CR1", "P2RY12", "C1QB", "C1QA", "CASZ1", "FLT1", "TF", "MOBP", "MOG", "MBP", "OLIG2", "OLIG1", "ST18", "GFAP", "AQP4", "SEMA3E", "EPHA4", "PPP1R1B", "DRD2", "DRD1", "GAD2", "GAD1", "SYT1", "RBFOX3", "SLC17A6", "SLC17A7")

Dotplot = DotPlot(object = KK_CaH_rxn1_neuron_clean, features = marker_genes, group.by = "RNA_snn_res.0.6")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)
```
```{r}
Idents(KK_CaH_rxn1_neuron_clean) = KK_CaH_rxn1_neuron_clean$RNA_snn_res.0.6

classes = c("D1_matrix", "D2_matrix", "non_SPN", "eSPN", "D1_patch", "non_SPN", "D2_patch", "non_SPN", "non_SPN", "doublet", "non_SPN", "doublet")

KK_CaH_rxn1_neuron_clean= assignCellClasses(KK_CaH_rxn1_neuron_clean, classes=classes, cluster_col="RNA_snn_res.0.6", class_col = "neuronal_cell_class")

DimPlot(KK_CaH_rxn1_neuron_clean, group.by = "neuronal_cell_class" ,label = T, raster = FALSE)
```
```{r}
KK_CaH_rxn1_neuron_clean
KK_CaH_rxn1_neuron_clean = subset(KK_CaH_rxn1_neuron_clean, subset = neuronal_cell_class != "doublet")
KK_CaH_rxn1_neuron_clean
```






```{r}

```

```{r}
KK_CaH_rxn1_oligo_clean@meta.data$neuronal_cell_class = "oligo"
KK_CaH_rxn1_opc_clean@meta.data$neuronal_cell_class = "opc"
KK_CaH_rxn1_micro_clean@meta.data$neuronal_cell_class = "microglia"
KK_CaH_rxn1_immune_clean@meta.data$neuronal_cell_class = "immune"
KK_CaH_rxn1_ependymal_clean@meta.data$neuronal_cell_class = "ependymal"
KK_CaH_rxn1_endo_clean@meta.data$neuronal_cell_class = "endothelial"
KK_CaH_rxn1_astro_clean@meta.data$neuronal_cell_class = "astrocyte"

KK_CaH_rxn1_neuron_clean@meta.data
KK_CaH_rxn1_micro_clean@meta.data

```


```{r}
sobj_list = list(KK_CaH_rxn1_neuron_clean,
KK_CaH_rxn1_oligo_clean,
KK_CaH_rxn1_opc_clean,
KK_CaH_rxn1_micro_clean,
KK_CaH_rxn1_immune_clean,
KK_CaH_rxn1_ependymal_clean,
KK_CaH_rxn1_endo_clean,
KK_CaH_rxn1_astro_clean)

sobj_list
```


#create sobj
```{r}
counts_list <- lapply(sobj_list, function(sobj) GetAssayData(sobj, slot = "counts"))

merged_counts <- do.call(cbind, counts_list)

metadata_list <- lapply(sobj_list, function(sobj) sobj@meta.data)

merged_metadata <- do.call(rbind, metadata_list)
merged_metadata

stopifnot(all(rownames(merged_metadata) == colnames(merged_counts)))

# Create Seurat object
CaH_rxn1_cleaned_KK <- CreateSeuratObject(counts = merged_counts, meta.data = merged_metadata)
CaH_rxn1_cleaned_KK
```

```{r}
dim(merged_counts)
dim(merged_metadata)
lapply(sobj_list, function(sobj) dim(sobj))
merged_metadata <- merged_metadata[match(colnames(merged_counts), rownames(merged_metadata)), ]

setdiff(colnames(merged_counts), rownames(merged_metadata))  # Cells in counts but not in metadata
setdiff(rownames(merged_metadata), colnames(merged_counts))  # Cells in metadata but not in counts


```


```{r}
# this code should take 3-10 minutes
hvgs = getSeuratVarFeatureIntersectByCol(CaH_rxn1_cleaned_KK, subset_col="donor_id", original_nfeatures=2500)
n_dims_use=20
CaH_rxn1_cleaned_KK = (CaH_rxn1_cleaned_KK
   %>% NormalizeData() # log normalizes raw counts
   %>% ScaleData(features=hvgs, split.by="donor_id") # within each cell, for each gene scale the data (i.e. subtract the donor's mean and divide by the donor's standard deviation of that gene)
   %>% RunPCA(features=hvgs, npcs=n_dims_use) # Reduce the dimensions to the n_dims_use dimensions that best explain the data https://en.wikipedia.org/wiki/Principal_component_analysis
   %>% FindNeighbors(dims = 1:n_dims_use) # Finds every cells closest neighbors in the PCA space
   %>% FindClusters(resolution = 0.2) # finds clusters at a variety of resolutions
   %>% FindClusters(resolution = 0.3) # after clustering, the cluster labels are accessible via filtered_merged_caudate$RNA_snn_res.{resolution}
   %>% FindClusters(resolution = 0.4) # e.g.: filtered_merged_caudate$RNA_snn_res.0.4 here
   %>% FindClusters(resolution = 0.5)
   %>% FindClusters(resolution = 0.6)
   %>% FindClusters(resolution = 0.7)
   %>% FindClusters(resolution = 0.8)
   %>% FindClusters(resolution = 0.9)
   %>% FindClusters(resolution = 1)
   %>% RunUMAP(dims = 1:n_dims_use) # projects the PCA onto 2 dimensions, such that both "global structure" and "local structure" are optimally preserved
)

setwh = function(w, h){
   # set the width of the ensuing figures to w, height to h
   options(repr.plot.width = w, repr.plot.height = h)
}

DimPlot(CaH_rxn1_cleaned_KK, group.by = "donor_id") 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "GT") 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.2", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.3", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.4", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.5", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.6", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.7", label=T) 
DimPlot(CaH_rxn1_cleaned_KK, group.by = "RNA_snn_res.0.8", label=T)

DimPlot(CaH_rxn1_cleaned_KK, group.by = "cell_class", label=T)
DimPlot(CaH_rxn1_cleaned_KK, group.by = "neuronal_cell_class", label=T)
```

```{r}
 marker_genes <- c("SYT1", "RBFOX3", "GAD2", "SLC17A6","AQP4", "GINS3", "GFAP","C1QA", "C1QB", "CX3CR1", "P2RY12","FLT1", "DCN", "RGS5", "OLIG1", "MOG", "MOBP", "OLIG2", "VCAN", "GAPDH","ZBBX", "CFAP157", "CFAP299", "BSG","CD96", "NKG7", "SKAP1")
 Dotplot = DotPlot(object = CaH_rxn1_cleaned_KK, features = marker_genes, group.by = "RNA_snn_res.0.2")
Dotplot  <- Dotplot  + theme(axis.text.x = element_text(angle = 45, hjust = 1))+ coord_flip() 
print(Dotplot)
```

```{r}
Idents(CaH_rxn1_cleaned_KK) = CaH_rxn1_cleaned_KK$RNA_snn_res.0.2

classes = c("oligo", "astrocyte", "oligo", "neuron", "oligo", "microglia", "oligo", "astrocyte", "opc", "endothelial", "ependymal", "neuron", "oligo", "neuron", "neuron", "immune")


CaH_rxn1_cleaned_KK= assignCellClasses(CaH_rxn1_cleaned_KK, classes=classes, cluster_col="RNA_snn_res.0.2", class_col = "final_cell_class")

DimPlot(CaH_rxn1_cleaned_KK, group.by = "final_cell_class" ,label = T, raster = FALSE)

```




```{r}
filtered_CaH_rxn1_cellbender@meta.data

CaH_rxn1_cleaned_KK@meta.data
```

```{r}
KK_doublets = setdiff(filtered_CaH_rxn1_cellbender@meta.data$cell, CaH_rxn1_cleaned_KK@meta.data$cell)
head(KK_doublets)
length(KK_doublets)
```


```{r}
filtered_CaH_rxn1_cellbender@meta.data$KK_doublet = "Singlet" 
filtered_CaH_rxn1_cellbender$KK_doublet[filtered_CaH_rxn1_cellbender$cell %in% KK_doublets] = "KK_doublet"
filtered_CaH_rxn1_cellbender@meta.data
table(filtered_CaH_rxn1_cellbender$KK_doublet)
```

```{r}
filtered_CaH_rxn1_cellbender@meta.data

DF_CaH_rxn1
```

```{r}
DF_CaH_rxn1@meta.data

DF_CaH_rxn1@meta.data$KK_doublet = "Singlet" 
DF_CaH_rxn1$KK_doublet[DF_CaH_rxn1$cell %in% KK_doublets] = "Doublet"
DF_CaH_rxn1@meta.data
table(DF_CaH_rxn1$KK_doublet)

DF_CaH_rxn1@meta.data$final_doublets = "Singlet" 
DF_CaH_rxn1$final_doublets[DF_CaH_rxn1$cell %in% KK_doublets] = "Doublet"
DF_CaH_rxn1$final_doublets[DF_CaH_rxn1$GT == "Doublet"] = "Doublet"
DF_CaH_rxn1@meta.data
table(DF_CaH_rxn1$final_doublets)

```

```{r}
table(DF_CaH_rxn1$GT)
table(DF_CaH_rxn1$DF.classifications_0.25_0.01_511)
table(DF_CaH_rxn1$KK_doublet)
table(DF_CaH_rxn1$final_doublets)
```

```{r}
# Assuming DoubletFinder has already been run and results are stored in the metadata of seu_kidney:
# - "DF.classifications_0.25_0.09_774" stores "Singlet" or "Doublet"
# - "pANN_0.25_0.09_774" stores the pANN scores for each cell

# First, create a new classification column that includes low-confidence and high-confidence doublets
DF_CaH_rxn1$doublet_confidence <- ifelse(
  DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511 == "Doublet" & 
    DF_CaH_rxn1@meta.data$pANN_0.25_0.01_511 < 0.5, "Low Confidence Doublet", 
  ifelse(
    DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511 == "Doublet" & 
      DF_CaH_rxn1@meta.data$pANN_0.25_0.01_511 >= 0.5, "High Confidence Doublet", 
    "Singlet"
  )
)

# Now plot the cells, coloring by the doublet classification
library(Seurat)
DimPlot(DF_CaH_rxn1, group.by = "doublet_confidence", 
        cols = c("Singlet" = "lightgrey", "Low Confidence Doublet" = "orange", "High Confidence Doublet" = "red"))

```

```{r}
library(caret)  # For confusionMatrix function

# Extract classifications
true_labels <- DF_CaH_rxn1@meta.data$GT  # Ground truth labels ("Singlet" / "Doublet")
pred_labels <- DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.09_843  # DoubletFinder output

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Generate confusion matrix
conf_matrix <- confusionMatrix(pred_labels, true_labels)
print(conf_matrix)

```


```{r}
library(caret)  # For confusionMatrix function

# Extract classifications
true_labels <- DF_CaH_rxn1@meta.data$GT  # Ground truth labels ("Singlet" / "Doublet")
pred_labels <- DF_CaH_rxn1@meta.data$KK_doublet  # DoubletFinder output

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Generate confusion matrix
conf_matrix <- confusionMatrix(pred_labels, true_labels)
print(conf_matrix)
```



```{r}
library(caret)
library(ggplot2)
library(reshape2)  # For data manipulation

# Extract classifications
true_labels <- DF_CaH_rxn1@meta.data$KK_doublet  # Ground truth labels
pred_labels <- DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511  # DoubletFinder results

# Ensure factors have the same levels
true_labels <- factor(true_labels, levels = c("Singlet", "Doublet"))
pred_labels <- factor(pred_labels, levels = c("Singlet", "Doublet"))

# Compute confusion matrix
conf_matrix <- table(Predicted = pred_labels, True = true_labels)

# Convert to long format for ggplot2
conf_df <- as.data.frame(as.table(conf_matrix))
colnames(conf_df) <- c("Predicted", "True", "Freq")

ggplot(conf_df, aes(x = True, y = Predicted, fill = Freq)) +
    geom_tile() +
    geom_text(aes(label = Freq), color = "white", size = 6) +  # Add text labels
    scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Customize colors
    theme_minimal() +
    labs(title = "KK Doublets vs DoubletFinder", x = "True Label", y = "Predicted Label") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
DF_CaH_rxn1@meta.data
```


```{r}
library(ggplot2)
library(dplyr)

# Create a confusion matrix-like dataframe
df_confusion <- DF_CaH_rxn1@meta.data %>%
  select(DF.classifications_0.25_0.01_511, final_doublets, GT) %>%
  mutate(across(everything(), as.character)) %>%
  count(DF.classifications_0.25_0.01_511, final_doublets, GT)

# Plot using geom_tile
ggplot(df_confusion, aes(x = DF.classifications_0.25_0.01_511, y = final_doublets, fill = n)) +
  geom_tile(color = "white") +
  facet_wrap(~ GT) +  # Facet by ground truth
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Comparison of Doublet Calls",
       x = "DoubletFinder Call",
       y = "KK Call",
       fill = "Cell Count") +
  theme_minimal()

```

```{r}
library(ggplot2)
library(dplyr)

# Arrange cells by Vireo ground truth for clearer visualization
df <- DF_CaH_rxn1@meta.data %>% arrange(GT)

# Create a long format for facet heatmap
df_long <- df %>%
  pivot_longer(cols = c(DF.classifications_0.25_0.01_511, final_doublets, GT), names_to = "Method", values_to = "Classification")

# Heatmap-style tile plot
ggplot(df_long, aes(x = Method, y = cell, fill = Classification)) +
  geom_tile() +
  scale_fill_manual(values = c("Singlet" = "blue", "Doublet" = "red")) +
  labs(title = "Heatmap of Doublet Classification Per Cell",
       x = "Method",
       y = "Cell ID",
       fill = "Classification") +
  theme_minimal() +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())  # Hide cell labels for large datasets


```



```{r}
true_labels <- DF_CaH_rxn1@meta.data$final_doublets

# Calculate ROC AUC for DoubletFinder results
roc_curve <- roc(true_labels, DF_CaH_rxn1@meta.data$pANN_0.25_0.01_511)
auc(roc_curve)

# Confusion Matrix
table(true_labels, DF_CaH_rxn1@meta.data$DF.classifications_0.25_0.01_511)
```


```{r}
df <- DF_CaH_rxn1@meta.data %>%
  select(pANN_0.25_0.01_511, final_doublets) %>%  # Replace 'pANN_col' with the actual column name in metadata
  mutate(
    KK_binary = ifelse(final_doublets == "Doublet", 1, 0)  # Convert Vireo ground truth to 1 (doublet) / 0 (singlet)
  )

# Compute ROC Curve using pANN scores
roc_pANN <- roc(df$KK_binary, df$pANN_0.25_0.01_511)  # pANN_col should be the column with pANN scores

# Print AUC value
auc_value <- auc(roc_pANN)
print(paste("AUC =", round(auc_value, 3)))

# Plot ROC Curve
ggroc(roc_pANN) +
  ggtitle(paste("Doubletfinder vs KK (AUC =", round(auc_value, 3), ")")) +
  theme_minimal()
```




```{r}
df <- DF_CaH_rxn1@meta.data %>%
  select(final_doublets, GT) %>%  # Replace 'pANN_col' with the actual column name in metadata
  mutate(
    GT_binary = ifelse(GT == "Doublet", 1, 0),
    KK_binary = ifelse(final_doublets == "Doublet", 1, 0),
    # Convert Vireo ground truth to 1 (doublet) / 0 (singlet)
  )

# Compute ROC Curve using pANN scores
roc_pANN <- roc(df$GT_binary, df$KK_binary)  # pANN_col should be the column with pANN scores

# Print AUC value
auc_value <- auc(roc_pANN)
print(paste("AUC =", round(auc_value, 3)))

# Plot ROC Curve
ggroc(roc_pANN) +
  ggtitle(paste("Vireo vs KK (AUC =", round(auc_value, 3), ")")) +
  theme_minimal()
```

```{r}
DF_CaH_rxn1@meta.data
```

```{r}
DF_CaH_rxn1$GT #vireo doublets
DF_CaH_rxn1$final_doublets #doublets manual filtering
DF_CaH_rxn1$DF.classifications_0.25_0.001_511 #doubletfinder

```


```{r}
table(DF_CaH_rxn1$GT, DF_CaH_rxn1$final_doublets, DF_CaH_rxn1$DF.classifications_0.25_0.001_511)
```


```{r}
DF_CaH_rxn1$doublet_agreement <- paste(
  DF_CaH_rxn1$GT,
  DF_CaH_rxn1$final_doublets,
  DF_CaH_rxn1$DF.classifications_0.25_0.001_511,
  sep = "_"
)

table(DF_CaH_rxn1$doublet_agreement)

```

```{r}
DF_CaH_rxn1$doublet_status <- ifelse(
  (DF_CaH_rxn1$GT == "Doublet" & DF_CaH_rxn1$final_doublets == "Doublet" & DF_CaH_rxn1$DF.classifications_0.25_0.001_511 == "Doublet"), 
  "Triple Agree", 
  "Other"
)

DimPlot(DF_CaH_rxn1, group.by = "doublet_status", cols = c("blue", "red"))

```

```{r}
library(ComplexUpset)

# Convert columns to binary (1 = doublet, 0 = singlet)
doublet_matrix <- data.frame(
  Vireo = DF_CaH_rxn1$GT == "Doublet",
  Manual = DF_CaH_rxn1$final_doublets == "Doublet",
  DoubletFinder = DF_CaH_rxn1$DF.classifications_0.25_0.001_511 == "Doublet"
)

doublet_matrix
# Make UpSet plot
ComplexUpset::upset(doublet_matrix, names(doublet_matrix))


```

```{r}
doublet_matrix <- data.frame(
  #Vireo = DF_CaH_rxn1$GT == "Doublet",
  Manual = DF_CaH_rxn1$final_doublets == "Doublet",
  DoubletFinder = DF_CaH_rxn1$DF.classifications_0.25_0.001_511 == "Doublet"
)

doublet_matrix
# Make UpSet plot
ComplexUpset::upset(doublet_matrix, names(doublet_matrix))


```

